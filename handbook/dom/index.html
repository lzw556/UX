<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>W3C DOM4</title>
    <link rel="stylesheet" href="/CSS/base.css">
</head>
<body>
    <hr>
    <h1>W3C DOM4</h1>
    <p><strong>Contents</strong></p>
    <ul class="table-of-content">
        <li>
            <a href="#border">1 Conformance</a>
            <ul class="table-of-content">
                <li><a href="#border-width">1.1 Dependencies</a></li>
                <li><a href="#border-color">1.2 Extensibility</a></li>
            </ul>
        </li>
        <li>
            <a href="#border">2 Terminology</a>
            <ul class="table-of-content">
                <li><a href="#border-width">2.1 Trees</a></li>
                <li><a href="#border-color">2.2 Strings</a></li>
                <li><a href="#border-style">2.3 Ordered sets</a></li>
                <li><a href="#border-shorthand">2.4 Namespaces</a></li>
            </ul>
        </li>
        <li>
            <a href="#box-dimension">3 Events</a>
            <ul class="table-of-content">
                <li><a href="DOM-event-introduction">3.1 Introduction to "DOM Events"</a></li>
                <li><a href="#event">3.2 Interface Event</a></li>
                <li><a href="#customEvent">3.3 Interface CustomEvent</a></li>
                <li><a href="#event-constructing">3.4 Constructing events</a></li>
                <li><a href="#event-defining">3.5 Defining event interfaces</a></li>
                <li><a href="#eventTarget">3.6 Interface EventTarget</a></li>
                <li><a href="#event-dispatching">3.7 Dispatching events</a></li>
                <li><a href="#fire">3.8 Firing events</a></li>
            </ul>
        </li>
        <li>
            <a href="#node">4 Nodes</a>
            <ul class="table-of-content">
                <li><a href="#DOM-introduction">4.1 Introduction to "The DOM"</a></li>
                <li><a href="#nodeTree">4.2 Node tree</a>
                    <ul>
                        <li><a href="#mutation">4.2.1 Mutation algorithms</a></li>
                        <li><a href="#nonElementParentNode">4.2.2 Interface NonElementParentNode</a></li>
                        <li><a href="#parentNode">4.2.3 Interface ParentNode</a></li>
                        <li><a href="#nonDocumentTypeChildNode">4.2.4 Interface NonDocumentTypeChildNode</a></li>
                        <li><a href="#childNode">4.2.5 Interface ChildNode</a></li>
                        <li><a href="#oldCollection">4.2.6 Old-style collections: NodeList and HTMLCollection</a>
                            <ul>
                                <li><a href="#nodeList">4.2.6.1 Interface NodeList</a></li>
                                <li><a href="#HTMLCollection">4.2.6.2 Interface HTMLCollection</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#mutation-observer">4.3 Mutation observers</a>
                    <ul>
                        <li><a href="mutationObserver-interface">4.3.1 Interface MutationObserver</a></li>
                        <li><a href="queuing-mutation-record">4.3.2 Queuing a mutation record</a></li>
                        <li><a href="mutationRecord-interface">4.3.3 Interface MutationRecord</a></li>
                        <li><a href="gc">4.3.4 Garbage collection</a></li>
                    </ul>
                </li>
                <li><a href="#node-interface">4.4 Interface Node</a></li>
                <li><a href="#document-interface">4.5 Interface Document</a>
                    <ul>
                        <li><a href="DOMImplementation-interface">4.5.1 Interface DOMImplementation</a></li>
                    </ul>
                </li>
                <li><a href="#DocumentFragment-interface">4.6 Interface DocumentFragment</a></li>
                <li><a href="#DocumentType-interface">4.7 Interface DocumentType</a></li>
                <li><a href="#Element-interface">4.8 Interface Element</a>
                    <ul>
                        <li><a href="Attr-interface">4.8.1 Interface Attr</a></li>
                    </ul>
                </li>
                <li><a href="#CharacterData-interface">4.9 Interface CharacterData</a></li>
                <li><a href="#Text-interface">4.10 Interface Text</a></li>
                <li><a href="#ProcessingInstruction-interface">4.11 Interface ProcessingInstruction</a></li>
                <li><a href="#Comment-interface">4.12 Interface Comment</a></li>
            </ul>
        </li>
        <li><a href="#ranges">5 Ranges</a></li>
        <li>
            <a href="#traversal">6 Traversal</a>
            <ul class="table-of-content">
                <li><a href="#border-width">8.4.1 Border width</a></li>
                <li><a href="#border-color">8.4.2 Border color</a></li>
                <li><a href="#border-style">8.4.3 Border style</a></li>
                <li><a href="#border-shorthand">8.4.4 Border shorthand properties</a></li>
            </ul>
        </li>
        <li>
            <a href="#sets">7 Sets</a>
            <ul class="table-of-content">
                <li><a href="#border-width">8.4.1 Border width</a></li>
                <li><a href="#border-color">8.4.2 Border color</a></li>
                <li><a href="#border-style">8.4.3 Border style</a></li>
                <li><a href="#border-shorthand">8.4.4 Border shorthand properties</a></li>
            </ul>
        </li>
        <li>
            <a href="#historical">8 Historical</a>
            <ul class="table-of-content">
                <li><a href="#border-width">8.4.1 Border width</a></li>
                <li><a href="#border-color">8.4.2 Border color</a></li>
                <li><a href="#border-style">8.4.3 Border style</a></li>
                <li><a href="#border-shorthand">8.4.4 Border shorthand properties</a></li>
            </ul>
        </li>
    </ul>
    <h3><a name="box-dimension"></a>3.1 Introduction to "DOM Events"</h3>
    <h3><a name="event"></a>3.2 Interface Event</h3>
    <div>
        <pre>interface Event{
    //返回事件的类型, eg. "click"        
    readonly attribute DOMString        type;
    //返回一个对象, 事件被dispatched给了这个对象
    readonly attribute EventTarget?         target;
    //返回一个对象, 这个对象的event listener的callback正在被调用
    readonly attribute EventTarget?         currentTarget;

    const unsigned short        NONE = 0;
    const unsigned short        CAPTURING_PHASE = 1;
    const unsigned short        AT_TARGET = 2;
    const unsigned short        BUBBLING_PHASE = 3;
    //NONE: 一个事件在没有被dispatched时所处的阶段
    //CAPTURING_PHASE: 当一个事件被dispatched给了一个对象(event.target), 在事件到达event.target之前其所处的阶段
    //AT_TARGET: 当一个事件被dispatched给了一个对象(event.target), 在事件到达event.target时所处的阶段
    //BUBBLING_PHASE: 当一个事件被dispatched给了一个对象(event.target), 在事件离开event.target之后其所处的阶段
    readonly attribute unsigned short       eventPhase;

    //阻止事件到达任何对象, 除了currentTarget
    void stopPropagation();
    //阻止事件到达任何对象, 除了currentTarget; 
    //并且执行完当前的event listener后, 不会继续调用currentTarget上注册的其他event listener
    void stopImmediatePropagation();

    //返回true or false, 表示该事件是否会向上冒泡 
    readonly attribute boolean      bubbles;
    //返回true or false, 表示该事件是否支持取消; 如果是true表示可以通过调用preventDefault()方法来取消事件的默认行为
    readonly attribute boolean      cancelable;

    //如果cancelable是true, 调用此方法可以取消事件的默认行为
    void preventDefault();
}</pre>
    </div>
    <p>每一个事件都有以下相关的标记, 这些标记一开始都是没有设置的</p>
    <ul>
        <li>stop propagation flag</li>
        <li>stop immediate propagation flag</li>
        <li>canceled flag</li>
        <li>initialized flag</li>
        <li>dispatch flag</li>
    </ul>
    <p>stopPropagation()方法必须设置stop propagation flag</p>
    <p>stopImmediatePropagation()方法必须设置stop propagation flag和stop immediate propagation flag</p>
    <p>如果event.cancelable是true, preventDefault()方法必须设置canceled flag</p>
    <p>初始化一个事件对象, 需要以下步骤:</p>
    <ol>
        <li>设置 initialized flag</li>
        <li>取消 stop propagation flag, stop immediate propagation flag, and canceled flag 的设置</li>
        <li>设置 target 属性为null</li>
        <li>设置 type 属性为type</li>
        <li>设置 bubbles 属性为bubbles</li>
        <li>设置 cancelable 属性为cancelable</li>
    </ol>
    <h3><a name="customEvent"></a>3.3 Interface CustomEvent</h3>
    <h3><a name="event-constructing"></a>3.4 Constructing events</h3>
    <h3><a name="event-defining"></a>3.5 Defining event interfaces</h3>
    <h3><a name="eventTarget"></a>3.6 Interface EventTarget</h3>
    <div>
        <pre>interface EventTarget{
    //向EventTarget的event listener列表中添加一个event listener
    //当capture是true时, 表示capture listener; 是false or 未设置时表示bubbling listener
    //在CAPTURING_PHASE阶段, 只会调用capture listener中的callback
    //在BUBBLING_PHASE阶段, 只会调用bubbling listener中的callback
    //在AT_TARGET阶段, 会调用所有类型的event listener
    void addEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
    void removeEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
    boolean dispatchEvent(Event event);
}</pre>
    </div>
    <p>EventTarget是一个对象, 当something发生时event被dispatched给了这个对象. 每一个EventTarget都有一个相关的列表, 用来存放event listener</p>
    <p>每一个event listener都有一个相关的callback, 这个callback的参数是event对象</p>
    <h3><a name="event-dispatching"></a>3.7 Dispatching events</h3>
    <p>把一个event dispatch给一个指定对象, 需要以下步骤:</p>
    <ol>
        <li>Let event be the event that is dispatched</li>
        <li>设置 dispatch flag</li>
        <li>初始化event对象的target属性为指定对象</li>
        <li>初始化event path, 这是一个有序列表, 把DOM tree中指定对象的所有祖先元素按自顶向下的顺序依次放进列表</li>
        <li>初始化event对象的eventPhase属性为CAPTUTING_PHASE</li>
        <li>遍历event path中的每一个对象, <a href="#invoking">调用当前对象的event listeners</a>, 只要stop propagation flag没有设置</li>
        <li>初始化event对象的eventPhase属性为AT_TARGET</li>
        <li><a href="#invoking">调用指定对象的event listeners</a>, 只要stop propagation flag没有设置</li>
        <li>
            如果event对象的bubbles 属性是true, 则执行如下步骤:
            <ol>
                <li>Reverse event path的顺序</li>
                <li>初始化event对象的eventPhase属性为BUBBLING_PHASE</li>
                <li>遍历event path中的每一个对象, <a href="#invoking">调用当前对象的event listeners</a>, 只要stop propagation flag没有设置</li>
            </ol>
        </li>
        <li>取消dispatch flag 设置</li>
        <li>初始化event对象的eventPhase属性为NONE</li>
        <li>初始化event对象的target属性为null</li>
    </ol>
    <p><a name="invoking" href="#">调用当前对象的event listeners</a>, 需要以下步骤:</p>
    <ol>
        <li>初始化event对象的currentTarget属性为evnet path上的当前对象</li>
        <li>遍历event listeners列表中的每一个event listener, 然后:
            <ol>
                <li>如果设置了stop immediate propagation flag, 终止所有的调用</li>
                <li>如果event对象的type属性不是listner的type, 终止并进入下一个event listener</li>
                <li>如果event对象的eventPhase属性是CAPTURING_PHASE并且listner的capture是false, 终止并进入下一个event listener</li>
                <li>如果event对象的eventPhase属性是BUBBLING_PHASE并且listner的capture是true, 终止并进入下一个event listener</li>
                <li>调用listner的callback的handleEvent</li>
            </ol>
        </li>
        
    </ol>
    <h3><a name="fire"></a>3.8 Firing events</h3>
    <h3><a name="parentNode"></a>4.2.2 Interface NonElementParentNode</h3>
    <div>
        <pre>interface NonElementParentNode {
    //返回 所有后代节点中 ID = elementId的 节点        
    Element? getElementById(DOMString elementId);
}
Document 实现了这个接口</pre>
    </div>
    <h3><a name="parentNode"></a>4.2.3 Interface ParentNode</h3>
    <div>
        <pre>interface ParentNode {
    //返回所有子节点中, nodeType = ELEMENT_NODE的 节点集合
    [SameObject] readonly attribute HTMLCollection children;
    //返回 所有子节点中 nodeType = ELEMENT_NODE的 第一个节点
    readonly attribute Element? firstElementChild;
    //返回 所有子节点中 nodeType = ELEMENT_NODE的 最后一个节点
    readonly attribute Element? lastElementChild;
    //返回 children.length
    readonly attribute unsigned long childElementCount;

    //返回 所有后代节点中 selector匹配到的 nodeType = ELEMENT_NODE的 第一个节点
    Element? querySelector(DOMString selectors);
    //返回 所有后代节点中 selector匹配到的 nodeType = ELEMENT_NODE的 节点集合(static)
    [NewObject] NodeList querySelectorAll(DOMString selectors);
}
Document 实现了这个接口
Element 实现了这个接口</pre>
    </div>
    <h3><a name="nonDocumentTypeChildNode"></a>4.2.4 Interface NonDocumentTypeChildNode</h3>
    <div>
        <pre>interface NonDocumentTypeChildNode {
    //返回所有前置兄弟节点中 nodeType = ELEMENT_NODE的 第一个节点
    readonly attribute Element? previousElementSibling;
    //返回所有后置兄弟节点中 nodeType = ELEMENT_NODE的 第一个节点
    readonly attribute Element? nextElementSibling;
}
Element 实现了 这个接口</pre>
    </div>
    <h3><a name="childNode"></a>4.2.5 Interface ChildNode</h3>
    <div>
        <pre>interface ChildNode {
    void remove();
};
Element 实现了这个接口</pre>
    </div>
    <h3><a name="oldCollection"></a>4.2.6 Old-style collections: NodeList and HTMLCollection</h3>
    <p>一个collection是一个对象表示DOM node的列表. 一个collection可以是live or static. 除特别说明, 一个collection必须是live</p>
    <p>如果一个collection是live, 那么这个collection的属性和方法操作的必须是真实的源数据而非快照</p>
    <h4><a name="nodeList"></a>4.2.6.1 Interface NodeList</h4>
    <div>
        <pre>interface NodeList {
    //也可以使用属性表示法 eg. node = collection[index]        
    getter Node? item(unsigned long index);
    readonly attribute unsigned long length;
    iterable&lt;Node&gt;;
}</pre>
    </div>
    <h4><a name="HTMLCollection"></a>4.2.6.2 Interface HTMLCollection</h4>
    <div>
        <pre>interface HTMLCollection {
    readonly attribute unsigned long length;
    //也可以使用属性表示法 eg. element = collection[index]   
    getter Element? item(unsigned long index);
    //也可以使用属性表示法 eg. element = collection[name]
    getter Element? namedItem(DOMString name);
}</pre>
    </div>
    <h3><a name="mutation-observer"></a>4.3 Mutation observers(变动观察器)</h3>
    <h3><a name="mutationobserver-interface"></a>4.3.1 Interface MutationObserver</h3>
    <div>
        <pre>interface MutationObserver {
    //指示UA观察target然后基于options报告变化
    //options对象
        //childList, 设置为true, 表示观察目标子节点的变化
        //attributes, 设置为true, 表示观察目标特性的变化
        //characterData
        //subtree, 设置为true, 表示观察目标及其后代节点的变化
        //attributeOldValue, 设置为true并且attributes为true或者忽略, 表示可以记录观察前目标的特性值
        //characterDataOldValue
        //attributeFilter, 如果不是所有的特性变化都要观察, 此时设置一个列表并且attributes为true或者忽略
    void observe(Node target, <a href="#mutationObserverInit">MutationObserverInit</a> options);
    //停止观察变化
    void disconnect();
    sequence&lt;<a href="#mutationRecord">MutationRecord</a>&gt; takeRecords();
}
dictionary <span id="mutationObserverInit">MutationObserverInit</span> {
    boolean childList = false;
    boolean attributes;
    boolean characterData;
    boolean subtree = false;
    boolean attributeOldValue;
    boolean characterDataOldValue;
    sequence<DOMString> attributeFilter;
}</pre>
    </div>
    <p><strong>constructor</strong></p>
    <div>
        <pre>new MutationObserver(callback);
var callback = function(record, mutationObserver){
    //do something
};
</pre>
    </div>
    <p>需要一个callback参数, 这个callback在新实例被observe()方法调用之后被调用</p>
    <p>callback可以传2个参数, 第一个是<a href="#mutationRecord">MutationRecord</a>对象, 第二个是新实例</p>
    <h3><a name="queuing-mutation-record"></a>4.3.2 Queuing a mutation record</h3>
    <h3><a name="mutationRecord-interface"></a>4.3.3 Interface MutationRecord</h3>
    <div>
        <pre>interface <span id="mutationRecord">MutationRecord</span>{
    readonly attribute DOMString type;
    readonly attribute Node target;
    [SameObject] readonly attribute NodeList addedNodes;
    [SameObject] readonly attribute NodeList removedNodes;
    readonly attribute Node? previousSibling;
    readonly attribute Node? nextSibling;
    readonly attribute DOMString? attributeName;
    readonly attribute DOMString? attributeNamespace;
    readonly attribute DOMString? oldValue;
}</pre>
    </div>
    <h3><a name="gc"></a>4.3.4 Garbage collection</h3>
    <h3><a name="node-interface"></a>4.4 Interface Node</h3>
    <div>
        <pre>interface Node : EventTarget {
    //nodeType
    const unsigned short ELEMENT_NODE = 1;
    const unsigned short TEXT_NODE = 3;
    const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
    const unsigned short COMMENT_NODE = 8;
    const unsigned short DOCUMENT_NODE = 9;
    const unsigned short DOCUMENT_TYPE_NODE = 10;
    const unsigned short DOCUMENT_FRAGMENT_NODE = 11;

    readonly attribute unsigned short nodeType;
    //如果nodeType=1(即元素节点), nodeName = tagName
    readonly attribute DOMString nodeName;

    readonly attribute DOMString? baseURI;
    //返回当前节点的顶层的 document 对象
    readonly attribute Document? ownerDocument;
    readonly attribute Node? parentNode;
    readonly attribute Element? parentElement;
    boolean hasChildNodes();
    [SameObject] readonly attribute NodeList childNodes;
    readonly attribute Node? firstChild;
    readonly attribute Node? lastChild;
    readonly attribute Node? previousSibling;
    readonly attribute Node? nextSibling;
                //如果nodeType=1(即元素节点), nodeValue = null
                attribute DOMString? nodeValue;
                //如果nodeType=1(即元素节点), textContent 是当前节点下 所有后代节点中 文本节点的内容的总和
                attribute DOMString? textContent;
    //将当前节点和它的后代节点"规范化", "规范化"之后, 不存在一个空的文本节点, 或者两个相邻的文本节点
    void normalize();

    //返回当前节点的copy, 如果deep是true, 这个copy包含当前节点的后代节点
    [NewObject] Node cloneNode(optional boolean deep = false);
    boolean isEqualNode(Node? node);

    const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
    const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
    const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
    const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
    const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
    unsigned short compareDocumentPosition(Node other);
    boolean contains(Node? other);

    DOMString? lookupPrefix(DOMString? namespace);
    DOMString? lookupNamespaceURI(DOMString? prefix);
    boolean isDefaultNamespace(DOMString? namespace);

    //into a parent before a child
    //操作parentNode的childNodes, 在参考节点之前插入一个新节点;
    //如果新节点已经存在, 将其从当前位置移动到新位置
    //返回插入的新节点
    Node insertBefore(Node node, Node? child);

    //相当于insertBefore(Node node, null);
    //操作parentNode的childNodes, 在其末尾插入一个新节点
    Node appendChild(Node node);

    //操作parentNode的childNodes, 用指定节点替换参考节点
    Node replaceChild(Node node, Node child);

    //操作parentNode的childNodes, 移除指定节点
    Node removeChild(Node child);
}</pre>
    </div>
    <h3><a name="document-interface"></a>4.5 Interface Document</h3>
    <div>
        <pre>interface Document : Node {
    [SameObject] readonly attribute DOMImplementation implementation;
    readonly attribute DOMString URL;
    readonly attribute DOMString documentURI;
    readonly attribute DOMString origin;
    //当前文档的渲染模式
    readonly attribute DOMString compatMode;
    readonly attribute DOMString characterSet;
    //如果docuemt是HTML, 返回text/html
    readonly attribute DOMString contentType;

    readonly attribute DocumentType? doctype;
    //如果docuemt是HTML, 返回HTMLHtmlElement实例
    readonly attribute Element? documentElement;
    //返回 所有后代元素中 指定tagName的 元素集合
    HTMLCollection getElementsByTagName(DOMString localName);

    HTMLCollection getElementsByClassName(DOMString classNames);

    [NewObject] Element createElement(DOMString localName);

    [NewObject] DocumentFragment createDocumentFragment();
    [NewObject] Text createTextNode(DOMString data);
    [NewObject] Comment createComment(DOMString data);
    [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);
    
    //返回指定节点的copy, 如果deep为true, 则copy中包含指定节点的后代
    //和node.cloneNode()区别:
    //1 node.cloneNode()中 node是在当前文档, 返回的copy也属于当前文档
    //2 importNode()中, 指定节点可以不在当前文档, 但是返回的copy属于当前文档(ownerDocument为当前文档)
    [NewObject] Node importNode(Node node, optional boolean deep = false);
    //从外部文档获取一个节点, 原节点和其后代节点会被删除;
    //返回的节点的ownerDocument为当前文档
    Node adoptNode(Node node);

    [NewObject] Event createEvent(DOMString interface);

    [NewObject] Range createRange();

    // NodeFilter.SHOW_ALL = 0xFFFFFFFF
    [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
    [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
}</pre>
    </div>
    <h3><a name="DOMImplementation-interface"></a>4.5 Interface DOMImplementation</h3>
    <h3><a name="DocumentFragment-interface"></a>4.6 Interface DocumentFragment</h3>
    <h3><a name="DocumentType-interface"></a>4.7 Interface DocumentType</h3>
    <h3><a name="Element-interface"></a>4.8 Interface Element</h3>
    <div>
        <pre>interface Element : Node {
    readonly attribute DOMString? namespaceURI;
    readonly attribute DOMString? prefix;
    readonly attribute DOMString localName;
    readonly attribute DOMString tagName;

                attribute DOMString id;
                attribute DOMString className;
    [SameObject] readonly attribute DOMTokenList classList;

    [SameObject] readonly attribute <a href="#namedNodeMap">NamedNodeMap</a> attributes;
    DOMString? getAttribute(DOMString name);

    void setAttribute(DOMString name, DOMString value);

    void removeAttribute(DOMString name);

    boolean hasAttribute(DOMString name);


    HTMLCollection getElementsByTagName(DOMString localName);

    HTMLCollection getElementsByClassName(DOMString classNames);
}</pre>
    </div>
    <h4><a name="namedNodeMap"></a>4.8.2 Interface NamedNodeMap</h4>
    <div>
        <pre>interface NamedNodeMap {
    //返回的节点 nodeType=2
    Node               getNamedItem(in DOMString name);
    Node               setNamedItem(in Node arg)
                                            raises(DOMException);
    Node               removeNamedItem(in DOMString name)
                                            raises(DOMException);
    //也可以通过属性表示法来访问
    Node               item(in unsigned long index);
    readonly attribute unsigned long   length;
}</pre>
    </div>
    <h3><a name="#CharacterData-interface"></a>4.9 Interface CharacterData</h3>
    <div>
        <pre>interface CharacterData : Node {
    [TreatNullAs=EmptyString] attribute DOMString data;
    readonly attribute unsigned long length;
    DOMString substringData(unsigned long offset, unsigned long count);
    void appendData(DOMString data);
    void insertData(unsigned long offset, DOMString data);
    void deleteData(unsigned long offset, unsigned long count);
    void replaceData(unsigned long offset, unsigned long count, DOMString data);
}</pre>
    </div>
    <h3><a name="#Text-interface"></a>4.10 Interface Text</h3>
    <div>
        <pre>interface Text : CharacterData {
    [NewObject] Text splitText(unsigned long offset);
    readonly attribute DOMString wholeText;
}</pre>
    </div>
    <h3><a name="#ProcessingInstruction-interface"></a>4.11 Interface ProcessingInstruction</h3>
    <div>
        <pre>interface ProcessingInstruction : CharacterData {
    readonly attribute DOMString target;
}</pre>
    </div>
    <h3><a name="#Comment-interface"></a>4.12 Interface Comment</h3>
    <div>
        <pre>interface Comment : CharacterData {
}</pre>
    </div>
    <h2><a name="ranges"></a>5 Ranges</h2>
    <h2><a name="traversal"></a>6 Traversal</h2>
    <h2><a name="sets"></a>7 Sets</h2>
</body>
</html>