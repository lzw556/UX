<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>5 reference type</title>
    <link href="/zwcss/css/main.css" rel="stylesheet">
    <link href="/zwcss/css/style.css" rel="stylesheet">
</head>
<body>
<div class="hd">
    <a href="scope.html">previous</a>&nbsp;&nbsp;&nbsp;<a href="object-oriented-programming.html">next</a>&nbsp;&nbsp;&nbsp;<a href="index.html">index</a>
</div> 
<div class="sidebar">
    <h1>5 reference type</h1>
    <ul class="table-of-content">
        <li><a href="#object">5.1 objcet type</a></li>
        <li><a href="#array">5.2 array type</a>
            <ul class="table-of-content">
                <li><a href="#detecting-array">5.2.1 detecting array</a></li>
                <li><a href="#conversion-method">5.2.2 conversion method</a></li>
                <li><a href="#stack-method">5.2.3 stack method</a></li>
                <li><a href="#queue-method">5.2.4 queue method</a></li>
                <li><a href="#reordering-method">5.2.5 reordering method</a></li>
                <li><a href="#manipulation-method">5.2.6 manipulation method</a></li>
                <li><a href="#location-method">5.2.7 location method</a></li>
                <li><a href="#iterative-method">5.2.8 iterative method</a></li>
                <li><a href="#reduction-method">5.2.9 reduction method</a></li>
            </ul>
        </li>
        <li><a href="#date">5.3 date type</a>
            <ul class="table-of-content">
                <li><a href="#inherited-method">5.3.1 inherited method</a></li>
                <li><a href="#date-formatting-method">5.3.2 date-formatting method</a></li>
                <li><a href="#component-method">5.3.3 date/time component method</a></li>
            </ul>           
        </li>
        <li><a href="#regular">5.4 regexp type</a>
            <ul class="table-of-content">
                <li><a href="#regular-property">5.4.1 regexp instance property</a></li>
                <li><a href="#regular-method">5.4.2 regexp instance method</a></li>
                <li><a href="#regular-static-property">5.4.3 regexp constructor property</a></li>
                <li><a href="#regular-limitation">5.4.4 pattern limitation</a></li>
            </ul>
        </li>
        <li><a href="#function">5.5 function type</a>
            <ul class="table-of-content">
                <li><a href="#nooverloading">5.5.1 no overloading</a></li>
                <li><a href="#declaration-vs-expression">5.5.2 declaration vs expression</a></li>
                <li><a href="#function-value">5.5.3 function as value</a></li>
                <li><a href="#function-internal">5.5.4 function internal</a></li>
                <li><a href="#function-property">5.5.5 property and method</a></li>
            </ul>
        </li>
        <li><a href="#wrapper-type">5.6 primitive wrapper type</a>
            <ul class="table-of-content">
                <li><a href="#boolean-type">5.6.1 boolean type</a></li>
                <li><a href="#number-type">5.6.2 number type</a></li>
                <li><a href="#string-type">5.6.3 string type</a></li>
            </ul>
        </li>
        <li><a href="#singleton-object">5.7 singleton built-in object</a>
            <ul class="table-of-content">
                <li><a href="#global-object">5.7.1 global object</a></li>
                <li><a href="#math-object">5.7.2 math object</a></li>
            </ul>
        </li>     
    </ul>    
</div>
<div class="main">
    <div class="section">
        <h2>5.1 object type<a name="object" class="anchor-link"></a></h2>
        <p>创建obejct实例有2种方法: 构造函数和对象字面量</p>
        <div class="example">           
            <pre>//构造函数
var person = new Object();
person.name = "lzw";
person.age = 18;

//对象字面量
var person = {
    name : "lzw",
    age : 18
};</pre>
        </div>       
        <p>访问对象属性的2种方法:点表示法和[]表示法. 两者区别在于[]表示法中可以使用变量</p> 
    </div>
    <div class="section">
        <h2>5.2 array type<a name="array" class="anchor-link"></a></h2>
        <p>创建数组的方式: 构造函数和数组字面量</p>
        <div class="example">           
                <pre>//构造函数
var colors = new Array();       
console.log(colors.length);     //0
console.log(colors[0]);         //undefined
//数值长度是2, 每一项值是undefined
var colors1 = new Array(2);         
console.log(colors1.length);    //0        
console.log(colors1[0]);        //undefined
//数值长度是3, 每一项值对应构造函数中的参数
var colors2 = new Array("red", "green", "blue");    
console.log(colors2.length);    //3
console.log(colors2[0]);        //red

//数组字面量
var color = ["red", "green", "blue"];</pre>
        </div>       
        <p>数组中元素的索引是从0开始的, 读取和设置数组中每一项的值的方法: arrayName[index]</p> 
        <p><strong>数值长度</strong></p>
        <p>这个值保存在length属性中, 在ECMAScript中数组的长度是动态的, 因此length不是只读的, 通过设置length的值可以在数组的末尾移除项和添加新项</p>
        <div class="example">
            <pre>var colors = ["red", "green"];
colors[colors.lenght] = "blue";     //会在数组的末尾增加一项</pre>
        </div>
    </div>
    <div class="section">
        <h3>5.2.1 detecting array<a name="detecting-array" class="anchor-link"></a></h3>
        <table class="table">
            <thead>
                <tr><th colspan="2">Array.isArray(value: any)</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>任何data type的值</td>
            </tr>
            <tr>
                <td>返回值</td><td>Boolean值</td>
            </tr>
            <tr>
                <td>功能</td><td>检测参数是否是数组(支持此方法的浏览器: IE9+)</td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h3>5.2.2 conversion method<a name="conversion-method" class="anchor-link"></a></h3>
        <div class="example">
            <pre>var colors = ["red", "green"];
//数值的toString()方法会返回由数组中每一项的字符串形式拼接而成的以逗号分隔的字符串
console.log(colors.toString());     //red,green
console.log(colors.toLocaleString());     //red,green
console.log(Array.isArray(colors.valueOf()))     //true</pre>
        </div>
    </div>
    <div class="section">
        <h3>5.2.3 stack method<a name="stack-method" class="anchor-link"></a></h3>
        <p>push()和pop()这2个方法, 不管是移除项还是增加项, 都发生在数组的末尾</p>
        <table class="table">
            <thead>
                <tr><th colspan="2">push()</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>任意数量, 任何data type的值</td>
            </tr>
            <tr>
                <td>返回值</td><td>修改后数组的长度</td>
            </tr>
            <tr>
                <td>功能</td><td>在数组的最后一项之后添加项</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">pop()</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>无</td>
            </tr>
            <tr>
                <td>返回值</td><td>被移除的项</td>
            </tr>
            <tr>
                <td>功能</td><td>移除数组中的最后一项</td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h3>5.2.4 queue method<a name="queue-method" class="anchor-link"></a></h3>
        <p>shift()和unshift()这2个方法, 不管是移除项还是增加项, 都发生在数组的头部</p>
        <table class="table">
            <thead>
                <tr><th colspan="2">shift()</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>无</td>
            </tr>
            <tr>
                <td>返回值</td><td>被移除的项</td>
            </tr>
            <tr>
                <td>功能</td><td>移除数组中的第一项</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">unshift()</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>任意数量, 任何data type的值</td>
            </tr>
            <tr>
                <td>返回值</td><td>修改后数组的长度</td>
            </tr>
            <tr>
                <td>功能</td><td>在数组的第一项之前添加项</td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h3>5.2.5 reordering method<a name="reordering-method" class="anchor-link"></a></h3>
        <table class="table">
            <thead>
                <tr><th colspan="2">reverse()</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>无</td>
            </tr>
            <tr>
                <td>返回值</td><td>原数组</td>
            </tr>
            <tr>
                <td>功能</td><td>反转数组项的顺序</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">sort([sortby: fn])</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>sortby, function, 比较函数, 可选<br>比较函数接受2个参数</td>
            </tr>
            <tr>
                <td>返回值</td>
                <td>
                    1 没有参数(默认情况)时, 把数组中每一项转换为字符串然后根据首字母的编码值升序排列, 然后返回原数组
                    <br>2 参数是比较函数时, 根据比较函数逻辑进行排序, 然后返回原数组
                </td>
            </tr>
            <tr>
                <td>功能</td><td>对数组项进行重新排序</td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h3>5.2.6 manipulation method<a name="manipulation-method" class="anchor-link"></a></h3>
        <table class="table">
            <thead>
                <tr><th colspan="2">concat()</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>任意数量, 任意data type的值</td>
            </tr>
            <tr>
                <td>返回值</td><td>新数组</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>创建当前数组的一个副本, 然后将参数添加到这个新数组的末尾</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">slice(start: number, [end: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>start, 整数, 表示开始索引 <br>end, 整数, 表示结束索引, 可选</td>
            </tr>
            <tr>
                <td>返回值</td>
                <td>
                    当只有一个参数时, 返回当前数组中从开始索引到末尾之间的项组成的新数组
                    <br>当有2个参数时, 返回当前数组中从开始索引到结束索引之间(不包括结束索引)的项组成的新数组
                </td>
            </tr>
            <tr>
                <td>功能</td>
                <td>
                   基于当前数组的一项或多项创建一个新数组
                </td>
            </tr>
        </table>
    </div>  
    <div class="section">
        <h3>5.2.7 location method<a name="location-method" class="anchor-link"></a></h3>
        <table class="table">
            <thead>
                <tr><th colspan="2">indexOf(searchElement: any, [fromIndex: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>searchElement, 任意类型, 要查找的项<br>fromIndex, 整数, 查找起点位置的索引</td>
            </tr>
            <tr>
                <td>返回值</td><td>如果存在返回其在数组中的位置索引, 否则返回-1</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>从第一项开始, 向后查找指定项在数组中的位置</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">lastIndexOf(searchElement: any, [fromIndex: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td><td>searchElement, 任意类型, 要查找的项<br>fromIndex, 整数, 查找起点位置的索引</td>
            </tr>
            <tr>
                <td>返回值</td><td>如果存在返回其在数组中的位置索引, 否则返回-1</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>从最后一项开始, 向前查找指定项在数组中的位置</td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h3>5.2.8 iterative method<a name="iterative-method" class="anchor-link"></a></h3>
        <table class="table">
            <thead>
                <tr><th colspan="2">every(callbackfn: fn, [thisArgs:])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    callbackfn, function, 要在每一项上运行的函数
                    <br>此函数接受3个参数分别是: 数组元素, 该元素的索引和数组本身
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>对数组中的每一项运行给定函数, 如果运行函数对每一项返回true,则返回true</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>检查数组中的项是否满足某个条件</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">filter(callbackfn: fn, [thisArgs:])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    callbackfn, function, 要在每一项上运行的函数
                    <br>此函数接受3个参数分别是: 数组元素, 该元素的索引和数组本身
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>对数组中的每一项运行给定函数, 返回该函数会返回true的项组成的新数组</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>用于查询符合条件的数组项</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">forEach(callbackfn: fn, [thisArgs:])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    callbackfn, function, 要在每一项上运行的函数
                    <br>此函数接受3个参数分别是: 数组元素, 该元素的索引和数组本身
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>无</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>对数组中的每一项运行给定函数, 本质上和使用for循环数组一样</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">some(callbackfn: fn, [thisArgs:])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    callbackfn, function, 要在每一项上运行的函数
                    <br>此函数接受3个参数分别是: 数组元素, 该元素的索引和数组本身
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>对数组中的每一项运行给定函数, 如果运行函数对任一项返回true,则返回true</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>检查数组中的项是否满足某个条件</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">map(callbackfn: fn, [thisArgs:])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    callbackfn, function, 要在每一项上运行的函数
                    <br>此函数接受3个参数分别是: 数组元素, 该元素的索引和数组本身
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>对数组中的每一项运行给定函数, 返回每次调用结果组成的新数组</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>适合创建一个与已知数组一一对应的新数组</td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h3>5.2.9 reduction method<a name="reduction-method" class="anchor-link"></a></h3>
        <p>reduce()和reduceRight()</p>
    </div>
    <div class="section">
        <h2>5.3 date type<a name="date" class="anchor-link"></a></h2>
        <p>date类型使用自UTC1970年1月1日0时开始经过的毫秒数来保存日期</p>
        <p><strong>构造函数</strong></p>
        <div class="example">
            <pre>var now = new Date();      //自动获取当前日期和时间
var date1 = new Date("2019-12-01");
//根据特定的日期和时间创建日期对象
var dateUTC1 = new Date(Date.parse("2019-12-06 10:16:36"));
var date1 = new Date("2019-12-06 10:16:36"); 

var dateUTC2 = new Date(Date.UTC(2019,11,6,10,16,36));
var date2 = new Date(2019,11,6, 10, 16,36);     //其中第二个参数表示月份, 0表示1月
            </pre>
        </div>
        <p>ECMAScript5中增加了Date.now(), 这个方法返回表示当前日期和时间的毫秒数</p>
        <p class="note">在不支持Date.now()的浏览器中, 可以用+new Date()把日期对象转换为Number值(即毫秒数)来达到相同的目的</p>
    </div>
    <div class="section">
        <h3>5.3.1 inherited method<a name="inherited-method" class="anchor-link"></a></h3>
        <div class="example">
            <pre>console.log(new Date().toString());        //带时区信息        
console.log(new Date().toLocaleString());         //带上午/下午信息, 不带时区               
console.log(new Date().valueOf());      //<span class="note">表示日期的毫秒数</span></pre>
        </div>
        <p><strong>比较2个日期对象的大小</strong></p>
        <p class="note">直接使用 &lt; or &gt; 操作符进行比较</p>
        <p>原因如下:</p>
        <ul>
            <li>2个日期对象在使用关系操作符比较大小时, 首先会调用valueOf()方法把对象转换为数值</li>
            <li>date类型的对象的valueOf()方法刚好返回的是数值</li>
        </ul>
    </div>
    <div class="section">
        <h3>5.3.2 date-formatting method<a name="date-formatting-method" class="anchor-link"></a></h3>
    </div>
    <div class="section">
        <h3>5.3.3 date/time component method<a name="component-method" class="anchor-link"></a></h3>
        <div class="example">
            <pre>var now = new Date();
console.log(now);           //Fri Dec 06 2019 15:17:25 GMT+0800 (中国标准时间)           
console.log(now.getTime());           //1575616645768, 返回表示日期的毫秒数
console.log(+now);           //1575616645768, 返回表示日期的毫秒数
console.log(now.valueOf());           //1575616645768, 返回表示日期的毫秒数
console.log(now.getFullYear());           //2019, 返回日期中4位数的年份
console.log(now.getMonth());           //11, 返回日期中的月份, 0表示1月
console.log(now.getDate());           //6, 返回日期中的天数(1-31)
console.log(now.getDay());           //5, 返回日期中的星期(0-6, 其中0表示星期日)
console.log(now.getHours());           //15, 返回日期中的小时数
console.log(now.getMinutes());           //17, 返回日期中的分钟数
console.log(now.getSeconds());           //25, 返回日期中的秒数
console.log(now.getMilliseconds());           //768, 返回日期中的毫秒数</pre>
        </div>
    </div>
    <div class="section">
        <h2>5.4 regexp type<a name="regular" class="anchor-link"></a></h2>
        <p><strong>正则表达式字面量</strong></p>
        <p>var expression = / pattern / flags; 其中flags有3种:</p>
        <ul>
            <li>g, 表示全局</li>
            <li>i, case-insensitive, 表示不区分大小写</li>
            <li>m, 表示多行</li>
        </ul>
        <div class="example">
            <pre>var pattern1 = /hello/g</pre>
        </div>
        <p><strong>正则表达式构造函数</strong></p>
        <div class="example">
            <pre>var pattern1 = new RegExp("hello", "g");</pre>
        </div>
    </div>
    <div class="section">
        <h3>5.4.1 regexp instance property<a name="regular-property" class="anchor-link"></a></h3>
        <p>global, ignoreCase, lastIndex, multiline, source</p>
    </div>
    <div class="section">
        <h3>5.4.2 regexp instance method<a name="regular-method" class="anchor-link"></a></h3>
        <p>exec(), test()</p>
    </div>
    <div class="section">
        <h3>5.4.3 regexp constructor perproty<a name="regular-static-property" class="anchor-link"></a></h3>
        <p>input, lastMatch,...etc</p>
    </div>
    <div class="section">
        <h3>5.4.4 pattern limitation<a name="regular-limitation" class="anchor-link"></a></h3>
    </div>
    <div class="section">
        <h2>5.5 function type<a name="function" class="anchor-link"></a></h2> 
        <p>每一个函数都是Function类型的实例, 和其他引用类型一样具有方法和属性<br>函数名是一个指向函数对象的指针, 不会与函数绑定</p>
        <p><strong>函数声明</strong></p>
        <div class="example">
            <pre>function sum(n1, n2){ return n1 + n2 ;}</pre>
        </div>
        <p><strong>函数表达式</strong></p>
        <div class="example">
            <pre>var sum = function(n1, n2){ return n1 + n2 ;}</pre>
        </div>
        <p><strong>构造函数</strong></p>
        <div class="example">
            <pre>var sum = new Function("n1", "n2", "return n1 + n2");</pre>
        </div>
    </div>
    <div class="section">
        <h3>5.5.1 no overloading<a name="nooverloading" class="anchor-link"></a></h3> 
        <p>因为函数是对象, 函数名是指针, 所以定义2个名字相同的函数本质上是先让这个指针指向第一个函数对象, 然后断开并指向第二个函数对象</p>
    </div>
    <div class="section">
        <h3>5.5.2 declaration vs expression<a name="declaration-vs-expression" class="anchor-link"></a></h3>
        <p><strong>区别:</strong></p> 
        <p>函数声明的代码不管在任何位置都会被解析器最先执行; 函数表达式则必须等到解析器执行到它所在的代码行时才会被执行</p>
        <p><strong>函数声明提升</strong></p>
        <p>解析器在执行任何代码之前, 读取并将函数声明添加到执行环境中</p>
        <div class="example">
            <pre>console.log(sum(10, 5));       //在定义函数sum之前调用
function sum(n1, n2){return n1 + n2;}</pre>
        </div>
    </div>
    <div class="section">
        <h3>5.5.3 function as value<a name="function-value" class="anchor-link"></a></h3> 
        <p>因为函数是对象, 所以可以和普通值一样作为函数的参数 or 返回值使用</p>
    </div>
    <div class="section">
        <h3>5.5.4 function internal<a name="function-internal" class="anchor-link"></a></h3>
        <p>arguments对象和this对象, 属于函数内部属性, 只能在函数体内部访问</p> 
        <p><strong>arguments</strong></p>
        <p>主要用途是保存函数参数, 这个对象还有一个属性callee, 该属性是一个指针, 指向当前正在执行的函数</p>
        <p><strong>this</strong></p>
        <p>函数体内的this, 指向函数的调用者</p>
    </div>
    <div class="section">
        <h3>5.5.5 property and method<a name="function-property" class="anchor-link"></a></h3> 
        <p><strong>属性:</strong> length和prototype</p>
        <p>每一个函数都有length属性, 表示函数希望接收的命名参数的个数</p>
        <p><a name="prototype"></a>prototype属性, 是引用类型中保存所有实例方法的所在, 不可以被枚举</p>
        <p><strong>方法:</strong> apply()和call()</p>
        <p>非继承方法, 用途都是在特定的作用域中<span class="note">调用函数</span>, 实际上等于设置函数体内this对象的值</p>
        <table class="table">
            <thead>
                <tr><th colspan="2">apply([thisArgs: any], [argsArray: Array])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    thisArgs, 任意类型, 在func运行时使用的this值, 可选
                    <br>argsArray, 一个数组或类数组对象, 其中的元素将作为单独的参数传递给func, 可选
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>func的返回值</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>在特定的作用域中<span class="note">调用函数</span></td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">call([thisArgs: any], [arg1], [arg2], ...)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    thisArgs, 任意类型, 在func运行时使用的this值, 可选
                    <br>[arg1], [arg2], ..., 参数列表, 可选
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>func的返回值</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>在特定的作用域中<span class="note">调用函数</span></td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h2>5.6 primitive wrapper type<a name="wrapper-type" class="anchor-link"></a></h2>
    </div>
    <div class="section">
        <h3>5.6.1 Boolean type<a name="boolean-type" class="anchor-link"></a></h3> 
        <p>Boolean类型的实例重写了valueOf()方法, 返回true or false</p>
    </div>
    <div class="section">
        <h3>5.6.2 Number type<a name="number-type" class="anchor-link"></a></h3> 
        <p>Number类型的实例重写了valueOf()方法, 返回对象表示的数值</p>
        <table class="table">
            <thead>
                <tr><th colspan="2">toFixed(value: number)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    value, Number, 指定显示的小数位
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>数值的字符串形式</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>按照指定小数位格式化数值</td>
            </tr>
        </table>
    </div>
    <div class="section">
        <h3>5.6.3 String type<a name="string-type" class="anchor-link"></a></h3> 
        <p><strong>字符方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">charAt(index: number)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    index, Number, 指定位置
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>给定位置的字符</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>查找指定位置的字符</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">charCodeAt(index: number)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    value, Number, 指定位置
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>给定位置字符的编码</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>查找指定位置的字符</td>
            </tr>
        </table>
        <p><strong>字符串操作方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">slice(start: number, [end: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    start, Number, 子字符串的开始位置
                    <br>end, Number, 子字符串的结束位置, 可选
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>当只有1个参数时, 返回当前字符串中从开始位置到字符串末尾之间的子字符串
                    <br>当有2个参数时, 返回当前字符串中从开始位置到结束位置(不包含结束位置)之间的子字符串
                </td>
            </tr>
            <tr>
                <td>功能</td>
                <td>创建子字符串</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">substring(start: number, [end: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    start, Number, 子字符串的开始位置
                    <br>end, Number, 子字符串的结束位置, 可选
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>当只有1个参数时, 返回当前字符串中从开始位置到字符串末尾之间的子字符串
                    <br>当有2个参数时, 返回当前字符串中从开始位置到结束位置(不包含结束位置)之间的子字符串
                </td>
            </tr>
            <tr>
                <td>功能</td>
                <td>创建子字符串</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">substr(start: number, [length: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    start, Number, 子字符串的开始位置
                    <br>length, Number, 子字符串的长度, 可选
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>当只有1个参数时, 返回当前字符串中从开始位置到字符串末尾之间的子字符串
                    <br>当有2个参数时, 返回当前字符串中从开始位置起指定长度的子字符串
                </td>
            </tr>
            <tr>
                <td>功能</td>
                <td>创建子字符串</td>
            </tr>
        </table>
        <p><strong>字符串位置方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">indexOf(searchString: string, [index: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    searchString, string, 要查找的子字符串
                    <br>index, number, 查找的起始位置, 可选
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>子字符串的位置</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>从字符串开头开始, 向后查找指定子字符串在字符串中的位置</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">lastIndexOf(searchString: string, [index: number])</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    searchString, string, 要查找的子字符串
                    <br>index, number, 查找的起始位置, 可选
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>子字符串的位置, 找不到返回-1</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>从字符串末尾开始, 向前查找指定子字符串在字符串中的位置</td>
            </tr>
        </table>
        <p><strong>trim()方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">trim()</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    无
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>一个字符串的副本, 删除前置和后置的所有空格</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>去除前后空格</td>
            </tr>
        </table>
        <p><strong>字符串大小写转换方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">toLowerCase()/toUpperCase()</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    无
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>一个字符串的副本, 转换为大写字母/小写字母</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>大小写转换</td>
            </tr>
        </table>
        <p><strong>字符串的模式匹配方法</strong></p>
        <p>match(), search(), replace(), split()</p>
    </div>
    <div class="section">
        <h2>5.7 singleton built-in object<a name="singleton-object" class="anchor-link"></a></h2> 
        <p>内置对象: 由ECMAScript实现提供的, 不依赖宿主环境的对象, 开发人员不需求显示实例化内置对象</p>
    </div>
    <div class="section">
        <h3>5.7.1 global object<a name="global-object" class="anchor-link"></a></h3> 
        <p><strong>URI编码方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">encodeURI(url: string)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    uri, string, 要编码的URI
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>有效的URI</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>对URI进行编码</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">encodeURIComponent(uriComponet: string)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    uriComponet, string, 要编码的URI
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>有效的URI</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>对URI进行编码</td>
            </tr>
        </table>
        <p>encodeURI()不会对本身属于URI的特殊字符进行编码, 比如":", "//", "?"和"&", 而encodeURIComponent()则会对这些字符进行编码</p>
        <p><strong>eval()方法</strong></p>
        <p><strong>global对象的属性</strong></p>
        <p>undefined, Infinity, NaN和原生引用类型的构造函数(Object, Array, Date, RegExp, Function等)</p>
        <p><strong>window对象</strong></p>
        <p>在web浏览器中, global对象被作为window对象的一部分加以实现</p>
    </div>
    <div class="section">
        <h3>5.7.2 math object<a name="math-object" class="anchor-link"></a></h3>
        <p>ECMAScript提供的数学公式和信息的对象</p>
        <p><strong>Math对象的属性</strong></p> 
        <p>比如, Math.PI, 表示圆周率π的值</p>
        <p><strong>min()和max()方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">Math.min(value1, value2, ...)/Math.max(value1, value2, ...)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    value1, value2, ... 任意多个数值参数
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>最小值/最大值</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>确定一组数值中的最小值和最大值</td>
            </tr>
        </table>
        <p><strong>舍入方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">Math.ceil(n: number)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    n, number, 小数值
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>将小数值向上舍入为最接近的整数</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>将小数值进行舍入, 转换为整数</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">Math.floor(n: number)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    n, number, 小数值
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>将小数值向下舍入为最接近的整数</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>将小数值进行舍入, 转换为整数</td>
            </tr>
        </table>
        <table class="table">
            <thead>
                <tr><th colspan="2">Math.round(n: number)</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    n, number, 小数值
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>将小数值四舍五入为最接近的整数</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>将小数值进行舍入, 转换为整数</td>
            </tr>
        </table>
        <p><strong>random()方法</strong></p>
        <table class="table">
            <thead>
                <tr><th colspan="2">Math.random()</th></tr>
            </thead>
            <tr>
                <td>参数</td>
                <td>
                    无
                </td>
            </tr>
            <tr>
                <td>返回值</td><td>大于0小于1的随机数</td>
            </tr>
            <tr>
                <td>功能</td>
                <td>取随机数</td>
            </tr>
        </table>
    </div>
</div>
<div class="ft">
    <a href="scope.html">previous</a>&nbsp;&nbsp;&nbsp;<a href="object-oriented-programming.html">next</a>&nbsp;&nbsp;&nbsp;<a href="index.html">index</a>
</div>  
<script>
function selectFrom(lower, upper){
    var total = upper -lower +1;
    return Math.floor(Math.random()*total +lower);
}
console.log(selectFrom(3, 20));
</script>
</body>
</html>