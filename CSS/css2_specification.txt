1 分类方法
  1.1 css文件的分类和引用顺序
      通常,一个项目我们只引用一个css文件,但对于较大的项目,我们需要把css文件进行分类.我们按照css的性质和用途,将css文件分成"公共型样式" "特殊型样式" "皮肤型样式",并以此顺序引用(按需求觉得是否添加版本号).
      1) 公共型样式:"标签的重置和设置默认值","统一调用背景图和清楚浮动或其他需统一处理的长样式","网站统一布局","通用模块和扩展","元件和扩展","功能类样式","皮肤类样式";
      2) 特殊型样式:当某个栏目或页面的样式与网站整体差异较大或者维护率较高时,可以独立引用一个样式:"特殊的布局/模块/元件及扩展","特殊的功能/颜色/背景",也可以是某个大型控件或模块的独立样式;
      3) 皮肤型样式:如果产品需要换肤功能,那么我们需要将颜色/背景等抽离出来放在这里;
      eg.
      <link href="assets/css/global.css" rel="stylesheet" type="text/css"/>
	  <link href="assets/css/index.css" rel="stylesheet" type="text/css"/>
	  <link href="assets/css/skin.css" rel="stylesheet" type="text/css"/>
  
  1.2 CSS内部的分类及其顺序
      1) 重置(reset)和默认(base):消除浏览器默认样式和浏览器差异,并设置部分标签的初始样式,以减少后面的重复劳动！你可以根据你的网站需求设置
      2) 建议在这个位置统一调用背景图（这里指多个布局或模块或元件共用的图）和清除浮动（这里指通用性较高的布局、模块、元件内的清除）等统一设置处理的样式
      3) 布局（grid）（.g-）：将页面分割为几个大块，通常有头部、主体、主栏、侧栏、尾部等
      4) 模块（module）（.m-）：通常是一个语义化的可以重复使用的较大的整体！比如导航、登录、注册、各种列表、评论、搜索等
      5) 元件（unit）（.u-）：通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中！比如按钮、输入框、loading、图标等
      6) 功能（function）（.f-）：为方便一些常用样式的使用，我们将这些使用率较高的样式剥离出来，按需使用，通常这些选择器具有固定样式表现，比如清除浮动等！不可滥用
      7) 皮肤（skin）（.s-）：如果你需要把皮肤型的样式抽离出来，通常为文字色、背景色（图）、边框色等，非换肤型网站通常只提取文字色！非换肤型网站不可滥用此类
      8) 状态（.z-）：为状态类样式加入前缀，统一标识，方便识别，她只能组合使用或作为后代出现
      eg.
        /* 重置 */
		div,p,ul,ol,li{margin:0;padding:0;}
		/* 默认 */
		strong,em{font-style:normal;font-weight:bold;}
		/* 统一调用背景图 */
		.m-logo a,.m-nav a,.m-nav em{background:url(images/sprite.png) no-repeat 9999px 9999px;}
		/* 统一清除浮动 */
		.g-bdc:after,.m-dimg ul:after,.u-tab:after{display:block;visibility:hidden;clear:both;height:0;overflow:hidden;content:'.';}
		.g-bdc,.m-dimg ul,.u-tab{zoom:1;}
		/* 布局 */
		.g-sd{float:left;width:300px;}
		/* 模块 */
		.m-logo{width:200px;height:50px;}
		/* 元件 */
		.u-btn{height:20px;border:1px solid #333;}
		/* 功能 */
		.f-tac{text-align:center;}
		/* 皮肤 */
		.s-fc,a.s-fc:hover{color:#fff;}

2 命名规则
  1.1 使用类选择器,放弃ID选择器
      ID在一个页面中的唯一性导致了导致了如果以ID为选择器来写css,就无法重用;
  1.2 NEC特殊字符:
      "-"连字符."-"在本规范中并不表示连字符的含义,她只表示两种含义:分类前缀分隔符,扩展分隔符
  1.3 分类的命名方法:使用单个字母+"-"为前缀
      布局（grid）（.g-）；
      模块（module）（.m-）；
      元件（unit）（.u-）；
      功能（function）（.f-）；
      皮肤（skin）（.s-）；
      状态（.z-）
      注：在你样式中的选择器总是要以上面前五类开头，然后在里面使用后代选择器。如果这五类不能满足你的需求，你可以另外定义一个或多个大类，但必须符合单个字母+"-"为前缀的命名规则，即 .x- 的格式。
      特殊：.j-将被专用于JS获取节点，请勿使用.j-定义样式
  1.4 后代选择器命名
      1)约定长度大于等于2的类选择器为后代选择器;eg. .m-list .text{} .m-list .itm{}
      2)一个语义化的标签也可以是后代选择器; eg. .m-list li{}
      3)不允许单个字母的类选择器
      4)通过使用后代选择器的方法，你不需要考虑他的命名是否已被使用，因为他只在当前模块或元件中生效，同样的样式名可以在不同的模块或元件中重复使用，互不干扰；在多人协作或者分模块协作的时候效果尤为明显！后代选择器不需要完整表现结构树层级，尽量能短则短
      eg.
        /* 这里的.itm和.cnt只在.m-list中有效 */
		.m-list{margin:0;padding:0;}
		.m-list .itm{margin:1px;padding:1px;}
		.m-list .cnt{margin-left:100px;}
		/* 这里的.cnt和.num只在.m-page中有效 */
		.m-page{height:20px;}
		.m-page .cnt{text-align:center;}
		.m-page .num{border:1px solid #ddd;}
  1.5 相同语义的不同类命名
      方法：直接加数字或字母区分即可（如：.m-list、.m-list2、.m-list3等，都是列表模块，但是是完全不一样的模块）
  1.6 模块和元件的扩展类的命名方法
      当A、B、C、...它们类型相同且外形相似区别不大，那么就以它们中出现率最高的做成基类，其他做成基类的扩展;
      eg.
      .m-list的扩展类为.m-list-1、.m-list-2
      基类自身可以独立使用（如：class="m-list"即可），扩展类必须基于基类使用（如：class="m-list m-list-2"）;
      如果你的扩展类是表示不同状态，那么你可以这样命名：u-btn-dis，u-btn-hov，m-box-sel，m-box-hov等等，然后像这样使用：class="u-btn u-btn-dis";
  1.7 模块和元件的后代选择器的扩展类
      有时候模块内会有些类似的东西，如果你没有把它们做成元件和扩展，那么也可以使用后代选择器和扩展
       eg.
       后代选择器：.m-login .btn{}
       后代选择器扩展：.m-login .btn-1{}，.m-login .btn-dis{}
  1.8 分组选择器有时可以代替扩展方法
      有时候虽然两个同类型的模块很相似，但是你希望他们之间不要有依赖关系，也就是说你不希望使用扩展的方法，那么你可以通过合并选择器来设置共性的样式
      eg.
        /* 两个元件共性的样式 */
		.u-tip1,.u-tip2{}
		.u-tip1 .itm,.u-tip2 .itm{}
		/* 在分别是两个元件各自的样式 */
		/* tip1 */
		.u-tip1{}
		.u-tip1 .itm{}
		/* tip2 */
		.u-tip2{}
		.u-tip2 .itm{}
  1.9 防止污染和被污染
      当模块或元件之间互相嵌套，且使用了相同的标签选择器或其他后代选择器，那么里面的选择器就会被外面相同的选择器所影响。所以，如果你的模块或元件可能嵌套或被嵌套于其他模块或元件，那么要慎用标签选择器，必要时采用类选择器，并注意命名方式，可以采用.m-layer .layerxxx、.m-list2 .list2xxx的形式来降低后代选择器的污染性

3 代码格式
  1.1 选择器、属性和值都使用小写
  1.2
  1.3
  1.4
  1.5
  1.6
4 优化方案
  1.1
  1.2
  1.3
  1.4
  1.5
  1.6
5 最佳实践
  1.1
  1.2
  1.3
  1.4
  1.5
  1.6
6 典型错误
  1.1
  1.2
  1.3
  1.4
  1.5
  1.6