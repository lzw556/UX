1、Object类型
			   1>创建Object对象的2种方式：构造函数   var person = new Object();
													 person.name = "lisi";
													 person.age = 22;
								  对象字面量表示法   var person = { name:"lisi",age:22 };
			   2>访问对象属性的2种方式：   点表示法  alert(person.name);
										   []表示法  alert(person["name"]);   这里将要访问的属性名以字符串的形式放在[]中。
2、Array类型
			   1>2个特点：数组中的每一项可以保存任意类型的值；数组的长度是可以动态变化的。
			   2>创建数组：构造函数 var array = new Array(); 数组字面量表示法 var array = [2,33,5];
			   3>length： 这个属性是可读可写的。通过设置length可以在数组的末尾添加或删除项
			   4>Array.isArray(arg):一个参数，返回true/false。判断参数是不是数组。
			   5>数组的toString()返回数组中的每一项拼接而成的以逗号隔开的字符串 例子： var arr1 = [12,true,"abc"];  alert(arr1.toString());返回12，true，abc
			   6>数组的valueOf()返回的原数组
			   7>join([String separator])：一个可选参数，返回数组中的每一项拼接而成的以separator隔开的字符串
			   8>栈方法：添加或移除都发生在数组的末尾。后进先出，即最新添加的最先被移除。栈中项的推入和移除只发生在一个地方-栈的顶部。
			           1、 push([...]): 任意个数的可选参数，该函数把这些参数逐个添加到数组的末尾，返回修改后数组的长度  例子：var arr1 = [12,true,"abc"];  alert(arr1.push("bbb",4,6)); 返回6
			           2、 pop():没有参数，该函数从数组末尾移除最后一项，减少数组的length，返回移除的项。
			   9>队列方法：在数组前端移除，在数组末尾添加。先进先出，即最早添加的最先被移除。
                       1、 shift():没有参数，该函数从数组开头移除第一项，减少数组的length，返回移除的项。
					     与其对应的方法unshift([..])：任意个数的可选参数，该函数把这些参数逐个添加数组的前端，返回修改后数组的长度。
			  10>排序方法：1、reverse():没有参数，该函数将原数组中的数据项反转并返回反转后的数组。例子：var arr1= [1,3,4,7]; alert(arr1.reverse()); 返回7,4,3,1
			               2、sort(Function comparefn): 一个参数，这个参数是一个比较函数，返回按比较函数排序后的数组。如果不传参数，则先求每一项的字符串值，然后
			                               根据首字母的asc值由小到大排序。
			                               例子：比较函数模板   function compare(value1,value2)
																{
																	if(value1<value2)
																	{
																		return -1;
																	}
																	else if(value1>value2)
																	{
																		return 1;//交换数组中前后2个数据项的位置
																	}
																	else
																	{
																		return 0;
																	}
																}
												var arr1=[2,1,33,6]; alert(arr1.sort(compare)); 返回1，2,6,33
							  总结：sort函数原理上还是冒泡排序。比较函数中的2个参数分别代表每次比较时的2个元素，返回正数是交换原数组中2个元素的位置，否则不交换。
									上面的比较函数可以简化为         function compare2(n1,n2)
																	 {
																		 return n1-n2;
																	 }
			   11>操作方法：1、concat([...]): 任意个数的可选参数，该函数先创建当前数组的一个副本，然后把接受到的参数添加到这个副本的末尾，返回一个新数组，但原数组保持不变。
			                2、slice(Number start,[Number end]): 1个参数或者2个参数。slice，中文切下的意思。该函数可以在原数组的基础上创建新数组，可以理解为从原数组的指定
			                    位置start复制到指定位置end，不会改变原数组。当参数个数为1时，返回指定位置到原数组末尾的所有项的新数组；当
								参数有2个时，返回起始和结束之间的项的新数组，但不包括结束位置的项。
								例子： var arr1 = [2, 1, 33, 6];  alert(arr1.slice(1,2)); 返回1
			                3、splice(Number start,Numbe deletecount,[...]):第一个参数表示起始位置；第二个参数表示要删除的项数，从start开始计算；第三个参数表示要插入的任意
			                    项[可选]；始终返回一个数组，该数组包含从原数组中删除的项，如果没有删除任何项，返回空数组。
			                    例子： var arr1 = [2, 1, 33, 6];
								删除   alert(arr1.splice(1,1));  返回1                          alert(arr1); 返回2,33,6
								插入   arr1.splice(0, 0, "jj");                                 alert(arr1); 返回jj,2,33,6
								替换   alert(arr1.splice(1, 1, "caomei", "love")); 返回1        alert(arr1); 返回2,caomei,love,33,6
								alert(arr1.splice(1, 1, "caomei", "love"));
			   12>位置方法：1、indexOf(searchElement,[Number fromIndex]): 2个参数，第一个是要查找的数组项，第2个时查找的起始位置索引，可选。该函数从数组的开头开始查找返回
			                   查找项在数组中的位置，如果找不到则返回-1
			                2、lastIndexOf(searchElement,[Number fromIndex]): 2个参数，第一个是要查找的数组项，第2个时查找的起始位置索引，可选；该函数从数组的末尾开始查找返回
			                   查找项在数组中的位置，如果找不到则返回-1
			   13>迭代方法：every()、 some() 、filter()、 forEach()、 map() 这几个函数都要接受2个参数：要在每一项上运行的函数和运行该函数的作用域对象(可选)。传入的
			                                                                运行函数都要接受3个参数：数组项的值，该项在数组中的索引和数组对象本身，以上方法都不会修改原数组。
			                every(Function callbackfn,[thisArg])：该函数对数组中的每一项运行给定函数，如果给定函数对每一项都返回true，则返回true。给定函数本身要返回一个boolean值。
			                some(Function callbackfn,[thisArg])： 该函数对数组中的每一项运行给定函数，如果给定函数对任一项返回true，则返回true。给定函数本身要返回一个boolean值。
？和委托挺像				filter(Function callbackfn,[thisArg])：该函数对数组中的每一项运行给定函数，返回给定函数会返回true的项组成的数组。运行函数本身返回一个boolean值。
？什么是回调函数			map(Function callbackfn,[thisArg])：该函数对数组中的每一项运行给定函数，返回给定函数每次调用的结果组成的数组
？这个方法有毛用     		forEach(Function callbackfn,[thisArg])：该函数对数组中的每一项运行给定函数，无返回值。相当于在for循环中操作数组中的每一项。
						另外2个：reduce()、reduceRight()：
3、Date类型：js中的date通过自1970年1月1日开始经过的毫秒数来保存日期。
               1>创建日期对象：var now = new Date();获取当前日期和时间     例子：alert(now)  返回 Mon Mar 17 2014 10:33:33 GMT+0800
			                                                                                      星期1 3月                 北京时区
							   now.toLocaleDateString()//返回2014/3/17   
							   now.toLocaleTimeString()//返回 10:33:33
							   now.GetHours()//返回小时
							   now.GetMinutes()//返回分钟
							   now.GetSeconds()//返回秒

						       var now = new Date(String date);            例子：var now = new Date("February 25,2015");    返回Wen Feb 25 2015 00:00:00 GMT+0800
							   var now = new Date(Number year,Number month,Number day,Number hours,Number minutes,Number seconds);
							                                               例子：var now = new Date(2014, 2, 12, 15, 13, 26);   返回 Wed Mar 12 2014 15:13:26 GMT+0800 
							   特别注意：有关月的数字，0-11代表 1-12月。
               2>Date.now()：没有参数，返回调用这个方法时的日期和时间的毫秒数。 
			   3>2个日期值可以直接通过比较操作符来比较大小
			   4>getTime()：没有参数，返回表示日期的毫秒数                                   例子var now = new Date(2014, 2, 12, 15, 13, 26);    alert(now.getTime()); 返回 1394608406000     
			   5>getDate()：没有参数，返回日期月份中的天数   其中0表示1月，11表示12月        例子var now = new Date(2014, 2, 12, 15, 13, 26);    alert(now.getDate()); 返回 12  
			   5>getDay()：没有参数，返回日期星期中的星期几 其中0表示星期日，6表示星期六     例子var now = new Date(2014, 2, 12, 15, 13, 26);    alert(now.getDay()); 返回 3  
4、RegExp类型
               var expression = /pattern/flag;    g:表示全局模式   i:不区分大小写  m:多行模式

5、Function类型:  js中函数实际是是Function类型的对象，拥有属性和方法，最重要的是函数名只是指向函数对象的指针，不会和函数绑定。
			   1>函数定义的2种方法：  函数声明     function method(n1,n2)
			                                       {
												       return n1+n2;
												   }
									  函数表达式   var sum= function(n1,n2)
									               {
												       return n1+n2;
												   };（这里的分号不要忘记）
									  区别：用函数声明定义的函数在被调用前解析器已经读取，而函数表达式则必须到执行到它所在的代码行时才被解析执行。
		       2>函数名仅仅是指向函数的指针。
			                          例子： function sum(n1,n2)
									         {
											     return n1 + n2;
											 }
											 alert(sum(12,10));   返回22
											 var anotherSum = sum;            //变量sum和anotherSum指向同一个函数。
											                                   注意使用不带圆括号的函数名是访问函数指针
											 alert(anotherSum(12,10)); 返回22
											 sum = null;
											 alert(anotherSum(12,10)); 返回22
			   3>实例理解js中没有重载
			                          例子：function sum(num)
									        {
											    return num +13;
											}
											function sum(num)
											{
											    return num +15;
											}                     
											alert(sum(15));    返回30，即后面的函数覆盖了前面的函数。第2个sum()实际上是变量sum指向了新的函数对象
									  上面的例子和下面的代码是等效的：
									        var sum = function(num)
											{ return num+13; };
											sum = function(num)
											{ return num +15; };

				4>函数当做返回值
				                       例子：var persons = [{name:"zs",age:23},{name:"ls",age:45}]; 要求按age属性排序。
									   function createComparisonFunction(propertyName)
									   {
											return function(object1,object2)
											{
											       var value1 = object1[propertyName];
												   var value2 = object2[propertyName];
												   return value1 -value2;
											}     
									   }
									   persons.sort(createComparisonFunction("age"));
									   alert(persons[0].age);
				 5>函数内部属性：arguments 和 this
				    arguments.callee：是一个指向函数自身的指针。经常用来在递归中代替函数名。
					阶乘例子：  function factorial(num)
								{
									if (num == 1) {
										return 1;
									}
									else {
										return num * arguments.callee(num-1);//arguments.callee在此处的妙用
									}
								}
								var trueFactorial = factorial;
								factorial = function ()
								{
									return 0;
								}
								alert(factorial(5));
								alert(trueFactorial(5));
			        this:
					     1>在函数中使用this：由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象，但有个原则
                                             就是this总是指向调用函数的那个对象。如果函数在全局作用域调用函数，那么this引用的是window对象，因为这时函数相当于window的方法
				    
					arguments.callee.caller:是一个指针，指向当前函数的调用者。
				 6>函数属性和方法：
				    1、length：表函数希望接收到的命名参数的个数    例子：function addNum(num){return num + 3;} alert(addNum.length); 返回1
					2、prototype：
					3、apply(thisArg,Array argArray)：2个参数，第一个参数就是this值，这个this值指向调用函数的对象。apply和call的作用都是把函数绑定到另一个对象上去运行。
					4、call(thisArg,[..])：2个参数，第一个参数就是this值，这个this值指向调用函数的对象
6、基本包装类型  Boolean、Number、String  每当读取一个基本类型的值时，后台会自动创建一个对应的基本包装类型的对象，这样就可以调用一些方法来操作这些数据。
                 
                 Number:toFixed(Number fractionDigits): 一个参数，表示显示几位小数；该函数返回指定小数点位数的数值的字符串值 
				                                        例子：   var n = 12; alert(n.toFixed(2)); 返回12.00
				 String:
				 1>length:返回字符串的字符个数。注意：双字节字符也算一个字符。
				 2>charAt(Number pos):一个参数，表示基于0的字符索引；该函数返回给定位置上的那个字符
				 3>charCodeAt(Number pos):一个参数，表示基于0的字符索引；该函数返回给定位置上的那个字符编码值
				 4>concat():不推荐使用
				 5>slice(Number start,[Number end]):2个参数，第一个表示开始位置，第二个表示结束位置，可选。该函数返回从(开始位置)到(结束位置-1）之间的字符串值，不会修改原字符串。
				 6>substr(Number strat,[Number length]):2个参数，第一个表示开始位置，第二个表示截取长度，可选。该函数返回从开始位置开始到指定长度之间的字符串值，不会修改原字符串。
				 7>substring(Number start,[Number end]):2个参数，第一个表示开始位置，第二个表示结束位置，可选。该函数返回从(开始位置)到(结束位置-1）之间的字符串值，不会修改原字符串。
				 8>indexOf(String searchString,Number position):2个参数，第一个表示要查询的字符串，第2个表示开始查询的位置，可选。该函数从原字符串的头开始向后查找，返回要查找的字符串
				                                                在原字符串中的位置，如果没有找到返回-1
				 9>lastIndexOf(String searchString,Number position):2个参数，第一个表示要查询的字符串，第2个表示开始查询的位置，可选。该函数从原字符串的尾开始向前查找，返回要查找的字符串
				                                                在原字符串中的位置，如果没有找到返回-1
				10>trim():没有参数，该函数会创建原字符串的一个副本，删除其中的所有空格，然后返回结果。不会修改原字符串。
				11>toLowerCase():没有参数，该函数返回原字符串的小写形式的字符串，不会修改原字符串
				12>toUpperCase():没有参数，该函数返回原字符串的大写形式的字符串，不会修改原字符串
				13>match():
				14>search():
				15>replace():
				16>split():
				17>localeCompare():
				18>String.fromCharCode():
7、Global
                 1>和window对象的区别：window对象只是在浏览器上才能使用的，window对象是宿主对象也就是在一定的环境中才会生成的对象.而global对象是在任何环境中都存在的,
				 可能楼主认为js只能用在浏览器,所以才有这样的想法,其实js还可以用在其他地方,比如UltraEdit就支持js脚本,那里面如果你用window.xx 肯定会报错,而你用parseInt等方法就正常。
				 所有在全局作用域中定义的属性和方法，都属于Global对象的属性。Web浏览器都是将这个全局对象当作window对象的一部分加以实现的,并不是js内置的对象,所以在web浏览器中可以
				 用window对象来代替Global对象
                 1>encodeURI(String uri):对url中无效的字符进行编码，不会对本身属于url的特殊字符进行编码
				 2>encodeURIComponent(String uriComponent):对url中所有无效的字符进行编码，不管这个字符是不是属于url本身
                 3>eval(String x): js中最强大的方法，相当于一个解析器。一个参数，即要执行的js语句，该函数
				                   将传入的参数当实际的js语句来执行
8、Math  
                 1>max(Number value1,Number value2,[...]):任意多个数值参数，返回一组数值中的最大值。
				 2>min(Number value1,Number value2,[...]):任意多个数值参数，返回一组数值中的最小值。
                 3>ceil(Number x): 向上舍入，即返回离他最近的比较大的整数	
				 4>floor(Number x):向下舍入，即返回离他最近的比较小的整数
				 5>round(Number x):标准舍入，即数学中的标准四舍五入
				 6>random():没有参数，返回大于0小于1的一个随机小数。  例子  alert(Math.random()); 返回0.34049080834102974	
				            这个函数的用途：可以从一个整数范围中随机选择一个值：
							                值 = Math.floor(Math.random() * 数值范围的总数 + 数值范围中第一个值）
										    		 
js中引用类型的总结：对象在js中被称为引用类型的值，而且有一些内置的引用类型可以创建特定的对象
                 1>Object是一个基础类型，其他所有类型都从Object继承了基本的行为
				 2>Array类型、Date类型、RegExp类型
				 3>Function类型，js中的函数实际上是Function类型的对象，由于函数是对象，所以拥有属性和方法
				 4>基本包装类型，作用是让基本类型的值可以被当作对象来访问
				 5>内置对象，Global和Math

                