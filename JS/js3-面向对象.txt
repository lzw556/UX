1、
2、创建对象
             1>简单工厂模式：即用函数把创建具体对象的过程封装起来
				   例子：       function createPerson(name, age, job)
								{
									var o = new Object();
									o.name = name;
									o.age = age;
									o.job = job;
									o.sayName = function () { alert(this.name)};
									return o;
								}
								var person1 = createPerson("zs", 18, "Softwear Engineer");//这句相当于将函数返回值赋值给变量person1,即让person1也指向这个o
								person1.sayName();
					缺点：用此方法创建的对象，无法判断具体类型
			  2>构造函数模式：
					例子：      function Person(name, age, job)
								{
									this.name = name;
									this.age = age;
									this.job = job;
									this.sayName = function () { alert(this.name); };
								}
								var person2 = new Person("ls", 19, "teacher");
								person2.sayName();
								alert(person2 instanceof Person);
					1、构造函数和普通函数唯一的区别：调用的方式不同。如果构造函数不通过new来调用，那他就是普通函数；反之，任何函数
					   如果通过new来调用，那他就是构造函数。
					2、缺点：通过构造函数创建的每个实例中，实例中的函数也被实例化了一次，即不同实例的sayName是不相等的。
			  3>原型模式：
			        例子：      function Person()
								{ }
								Person.prototype.name = "zl";
								Person.prototype.age = 28;
								Person.prototype.job = "soldier";
								Person.prototype.sayName = function () { alert(this.name); };
								var person3 = new Person();
								person3.sayName();
								var person4 = new Person();
								alert(person3.sayName == person4.sayName);
					 1、构造函数、原型对象和实例对象之间的关系：每个函数都有一个prototype属性，这个属性是一个指针，指向该构造函数的原型对象；
					    原型对象会自动获取一个constructor属性，这个属性是一个指针，指向构造函数；通过构造函数创建一个新实例，该实例内部
						将包含一个[[Prototype]]指针，指向构造函数的原型对象。（这本书上的图片能够帮助理解。）				   
					 2、原型对象的好处：所有实例对象共享一份它所包含的属性和方法，类似c#中类的静态成员
					 3、isPrototypeOf()：实例对象的[[Prototype]]虽然无法访问，但可以通过isPrototypeOf()来判断该实例对象和原型对象之间的关系
					 4、读取对象的属性：先在实例对象本身开始查找，如果找到给定名字的属性，则返回该属性的值；否则去原型对象中查找，如果找到返回
					    属性的值。因此如果在实例对象中添加一个属性，这个属性和该对象在原型对象中的一个属性同名，那么该属性会屏蔽原型对象中的属性。
						例子：继续上面的例子
						        person4.name = "ls";
								alert(person3.name);          //返回"zl"   ---这个name来自person3的原型
								alert(person4.name);          //返回"ls"   ---这个name来自person4
					 5、in操作符： 1>单独使用语法，属性名 in 对象。如果通过该对象可以访问这个属性，则返回true，否则返回false。
									 经典用法：判断某一属性是存在于在实例中还是存在于原型中
											function hasPrototypeProperty(object, name)
											{
												return !object.hasOwnProperty(name) && (name in object);
											}
									  object.hasOwnProperty(name) 返回true表示object实例对象中存在这个属性；
									  name in object 返回true表示通过object可以访问属性name
								   2>在for-in循环中，返回的是能够通过对象访问的、可以枚举的属性名。
								   3>Object.keys(Object v)：一个参数，返回一个数组。该函数返回接受对象中所有可枚举的实例属性的字符串的数组，
								                            不包括原型中的属性。
								   4>Object.getOwnPropertyNames(Object v)：一个参数，返回一个数组。该函数返回接受对象中所有的实例属性的字符串的数组。
					 6、更简单的原型语法：
					    例子：  function Person()
								{ }
								Person.prototype = {
									constructor: Person,//这种语法原型对象中的constructor默认不再指向Person，而是指向Object
									name: "lsc",        //所以如果还想让constructor指向Person，就必须显式设置
									age: 20,
									sayName: function () { alert(this.name); }
								};
								var person5 = new Person();
								alert(person5["name"] == person5.name);
								alert(Person.prototype.constructor == Person);
			  4>创建自定义类型的经典方法：就是使用构造函数模式和原型模式的组合，构造函数用于定义实例属性，而原型模式用于
			                              定义方法和共享的属性。
								        function Person(name, age, job)
										{
											this.name = name;
											this.age = age;
											this.job = job;
										}
										Person.prototype = {
											constructor: Person,
											sayName: function () { alert(this.name);}
										};	 
3、继承
              1>原型链：js中主要通过原型链来实现继承。语法就是 子类型.prototype = new 父类型构造函数();本质上是重写子类型的
			            原型对象，使其指向一个父类型的实例，这样子类型的原型对象不仅拥有父类型实例的所有属性和方法，而且其内部
						还有一个指针[[prototype]]，指向父类型的原型。（这本书上的图片能够帮助理解。）
						最终达到的效果就是：子类型的实例->子类型的原型对象->父类型的原型对象
						例子：          function SuperType()
										{
											this.superProperty = true;
										}
										SuperType.prototype.getSuperValue = function () {
											return this.superProperty;
										};
										function SubType()
										{
											this.subProperty = false;
										}
										SubType.prototype = new SuperType();
										SubType.prototype.getSubValue = function () {
											return this.subProperty;
										};
										var instance = new SubType();
										alert(instance.getSuperValue());
										alert(instance.getSubValue());
						原型链的缺点：引用类型值的实例属性在被继承后变成了原型对象中的属性
			  2>借用构造函数：就是在子类型的构造函数中调用父类型的构造函数。这样做的好处就是如果父类型的构造函数中定义了实例
			                  属性，那么通过借用，子类型也同样定义了这些实例属性。
							  例子：    function SuperType()
										{
											this.name = "zs";
											this.colors = ["red","green","blue"];
										}
										function SubType()
										{
											SuperType.call(this);
										}
										var instance = new SubType();
										instance.colors.push("black");
										var instance2 = new SubType();
										alert(instance.colors);
										alert(instance2.colors);			            
			  3>组合继承：思想就是用原型链来实现对原型属性和方法的继承，用借用构造函数来实现对实例属性的继承
4、闭包：有权访问另一个函数作用域中变量的函数。创建闭包的常见方式就是在一个函数内部定义另一个函数。
              1>闭包的作用：可以访问局部变量，但只能取得包含函数中任何变量的最后一个值。
			    例子：                  var outer = [];
										function clouseTest() {
											var array = ["one", "two", "three", "four"];
											for (var i = 0; i < array.length; i++) {
												var x = {};
												x.no = i;
												x.text = array[i];
												x.invoke = function () {
													alert(i);
												};
												outer.push(x);
											}
										}
										clouseTest();
										for (var i = 0; i < outer.length; i++) {
											outer[i].invoke();
										}
				                 最终弹出4 4 4 4
			  2>使用闭包的注意点：
			                    1、闭包中的this
						        例子：  //var name = "the window";
										//var object = {
										//    name: "the object", getNameFunc: function () {
										//        return function () { return this.name; };
										//    }
										//};
										//alert(object.getNameFunc()());
										object.getNameFunc()()相当于 (function(){return this.name;})()l
										匿名函数的执行环境有全局性
										var name = "the window";
										var object = {
											name: "the object", getNameFunc: function () {
												var that = this;
												return function () { return that.name; };
											}
										};
										alert(object.getNameFunc()());   
										把外部函数的this对象保存在一个闭包能访问到的变量that中       
								 2、内存泄露
								 由于IE9之前的版本使用的垃圾回收机制，可能会使闭包中存在的对象无法被自己回收的问题，解决办法就是手动解除引用。
5、块级作用域
                      1、js中没有块级作用域。	
					  2、可以用定义并立即调用匿名函数的方式来模拟块级作用域
					     语法：    (function(){
						               //函数体；
						            })();		
6、私有变量														    